import pandas as pd
import matplotlib.pyplot as plt
import sklearn
from sklearn.svm import OneClassSVM
from sklearn.cluster import DBSCAN
from Bio import pairwise2
import numpy as np
import pdb

def file_path_generation(sample_number):
    """
    This method generates out the file paths for all the files that are part of 1 sample

    :param sample_number: The sample number that needs to be entered to get all Frameworks and all Replicates
    :return: The file paths of all samples
    """

    files = []
    for framework_count in range(1, 4):
        for framework_value in ['A', 'B']:
            files.append(
                "Lymphotrack_Files/" + str(sample_number) + "FR" + str(framework_count) + framework_value + ".csv")
    return files


def create_mother_sequence_mask(mother_sequence):
    """
    Creates a trinucleotide mask for the mother sequence generated by CloneSeer.
    Shifts frame of 6 along the sequence and determines if  position 1 = position 4, position 2 = position 5,
    position 3 = position 6. If it matches, any 0 in the mask at that position turns into a 1

    :param mother_sequence: The most abundant sequence from data
    :return: Mask for mother sequence denoting trinucleotide
    """

    mother_sequence_trinucleotide = np.zeros(len(mother_sequence))
    for character_position in range(len(mother_sequence) - 6):
        if mother_sequence[character_position] == mother_sequence[character_position + 3] \
                and mother_sequence[character_position + 1] == mother_sequence[character_position + 4] \
                and mother_sequence[character_position + 2] == mother_sequence[character_position + 5]:
            for i in range(6):
                mother_sequence_trinucleotide[character_position + i] = 1
    return mother_sequence_trinucleotide


def trinucleotide(data, mother_sequence):
    """
    Creates columns that count the mismatches that occur in trinucleotides, deletions that occur in trinucleotides and
    insertions that occur in trinucleotides.
    :param data: Clone Seer file containing modified sequence, original sequence, number of times observed and inserts
    :param mother_sequence: The mother sequence that is observed most often
    :return: Columns representing mismatches that occur in trinucleotides, deletions that occur in trinucleotides and
    insertions that occur in trinucleotides.
    """
    mother_sequence_trinucleotide = create_mother_sequence_mask(mother_sequence)
    trinucleotide_mismatch_error = []
    dash_mismatch_error = []
    insert_mismatch_error = []
    for index, row in data.iterrows():
        trinucleotide_mismatch_count = 0
        dash_mismatch_count = 0
        insert_count = 0

        # Mismatches and deletions in trinucleotide checked using sequence from Clone Seer. Counts the number of
        # differences that appear between target sequence and mother sequence on a trinucleotide region

        for character_position in range(len(mother_sequence)):
            if row['sequence'][character_position] != mother_sequence[character_position] \
                    and row['sequence'][character_position] != "-" \
                    and mother_sequence_trinucleotide[character_position] == 1:
                trinucleotide_mismatch_count += 1
            if row['sequence'][character_position] != mother_sequence[character_position] and row['sequence'][
                character_position] == "-" and mother_sequence_trinucleotide[character_position] == 1:
                dash_mismatch_count += 1
        trinucleotide_mismatch_error.append(trinucleotide_mismatch_count)
        dash_mismatch_error.append(dash_mismatch_count)

        # Looks through the insert column and count the number of inserts that appear on the trinucleotide position.
        # Inserts at the end of the sequence do not increment insert count due to unreliability of sequencing at the end

        if row['inserts'] == '[]':
            insert_mismatch_error.append(0)
        else:
            insert_positions = row['inserts'][1:-1].split(',')
            for insert_position in insert_positions:
                if int(insert_position) > len(mother_sequence_trinucleotide) - 1 :#or int(insert_position) < 8:
                    insert_count += 0
                else:
                    if mother_sequence_trinucleotide[int(insert_position)] == 1:
                        insert_count += 1
            insert_mismatch_error.append(insert_count)
    return trinucleotide_mismatch_error, dash_mismatch_error, insert_mismatch_error


def get_total_deletions(data):
    """
    Counts the number of times a deletion occurs in a sequence represented by a dash in the sequence

    :param data: All data points
    :return: A column representing the number of deletions that appear in the sequence generated by Clone seer
    """
    return data.sequence.str.count('-')

def get_index_mismatch(data, mother_sequence):
    index_mismatch = []
    sequences = data['sequence'].tolist()
    for sequence in sequences:
        index_mismatch.append([i for i in range(len(sequence)) if sequence[i] != mother_sequence[i]])
    return index_mismatch
    
def homology_metrics(data, row_of_max_observed, mother_sequence):
    """
    :param data: All data from clone seer
    :param row_of_max_observed: The row with the mother sequence
    :param mother_sequence: The mother sequence representing the sequence that is observed the most
    :return: differences: homology column denoting difference between target sequence and mother sequence
    :return: new_differences: Contiguous blocks of homology differences ex. Diff: [2,3,3,1,0,2,2] Result: [-3, -2, -1, 0, 1]
    """

    # Calculate differences regardless of trinucleotide between target sequence and mother clone
    differences = []
    for index, row in data.iterrows():
        differences.append(sum(a != b for a, b in zip(row['sequence'], mother_sequence)))

    # Calculate differences based upon differences and order. Mother sequence is 0.
    # Getting value from first half
    first_half_value = []
    current_difference = differences[row_of_max_observed]
    count = 0
    for i in range(row_of_max_observed, -1, -1):
        if differences[i] != current_difference:
            count -= 1
            first_half_value.append(count)
            current_difference = differences[i]
        else:
            first_half_value.append(count)
    # Getting Second Half Value
    second_half_value = []
    current_difference = differences[row_of_max_observed]
    count = 0
    for i in range(row_of_max_observed + 1, len(differences)):
        if differences[i] != current_difference:
            count += 1
            second_half_value.append(count)
            current_difference = differences[i]
        else:
            second_half_value.append(count)
    new_difference = first_half_value[::-1] + second_half_value
    data['contiguous_homology_against_mother_clone'] = new_difference  # New Variable Name
    return differences, new_difference


def new_metrics(data):
    """
    Generates out more features for the data including deletion count, mismatch, deletion and insertion during trinucleotide,
    homology and contiguous homology differences with mother clone
    :param data: All data from Clone Seer file
    :return: data: Data with new metrics columns attached
    """
    
    # Mother Clone Identification
    row_of_max_observed = data['numberobserved'].idxmax()
    mother_sequence = data['sequence'][row_of_max_observed]


    
    # Number of deletions that appear in each sequence
    data['deletion_count'] = get_total_deletions(data)
    
    data['index_mismatch'] = get_index_mismatch(data, mother_sequence)

    # Mismatches, deletions, and insertions in trinucleotide regions
    data['mismatch_in_trinucleotide'], data['deletion_in_trinucleotide'], data['insertion_in_trinucleotide'] \
        = trinucleotide(data, mother_sequence)
    # Calculate homology differences and contiguous homology block differences
    data['homology_against_mother_clone'], data['contiguous_homology_against_mother_clone'] = homology_metrics(data, row_of_max_observed, mother_sequence)
    return data, row_of_max_observed, mother_sequence


def outlier_detection(data):
    """
    Takes in a file and finds all the outliers that can be subclones.
    1. Apply DBScan to all sequences except those who have a deletion or insertion on the trinucelotide and find the subclones
    2. Extract all deletions and find average and standard deviation. Deletions who have number observed greater than 1
    standard deviation about average are probable subclones
    3. Extract all insertions and find average and standard deviation. Insertions who have number observed greater than 1
    standard deviation about average are probable subclones
    :param file: File path of clone seer file
    :return: Array filled with likely subclones and mother clone in sequential order
    """

    #data = pd.read_csv(file)
    data_with_new_metrics, row_of_mother_clone, mother_clone = new_metrics(data)

    data_without_mother_clone = data_with_new_metrics.drop(index=row_of_mother_clone)
    data_with_insertion = data_without_mother_clone.loc[data_without_mother_clone['insertion_in_trinucleotide'] != 0]
    data_with_deletion = data_without_mother_clone.loc[data_without_mother_clone['deletion_in_trinucleotide'] != 0]

    model_1 = sklearn.cluster.DBSCAN(eps=200, min_samples=10).fit(data_without_mother_clone[['numberobserved', 'contiguous_homology_against_mother_clone']])
    colors_1 = model_1.labels_
    plt.scatter(data_without_mother_clone["numberobserved"], data_without_mother_clone['insertion_in_trinucleotide'], c=colors_1)
    plt.xlabel("number of times observed")
    plt.ylabel("contiguous_homology_against_mother_clone")

    outliers_list = np.zeros(len(data.index))
    outliers_list[row_of_mother_clone] = 1
    outliers_1 = data_without_mother_clone[model_1.labels_ == -1]
    for outlier_count in outliers_1.index.tolist():
        outliers_list[outlier_count] = 1
    # print(outliers_1['sequenceNotformatted'])

    df_insert_mean = data_with_insertion['numberobserved'].mean()
    df_insert_std = data_with_insertion['numberobserved'].std()
    df_deletion_mean = data_with_deletion['numberobserved'].mean()
    df_deletion_std = data_with_deletion['numberobserved'].std()
    df_insert_sequenceNotFormatted = data_with_insertion.loc[data_with_insertion['numberobserved'] >= df_insert_mean + df_insert_std]
    df_with_deletion_sequenceNotFormatted = data_with_deletion.loc[data_with_deletion['numberobserved'] >= df_deletion_mean + df_deletion_std]

    for outlier_count in df_insert_sequenceNotFormatted['sequenceNotformatted'].index.tolist():
        outliers_list[outlier_count] = 1
    for outlier_count in df_with_deletion_sequenceNotFormatted['sequenceNotformatted'].index.tolist():
        outliers_list[outlier_count] = 1
    data['outliers'] = outliers_list
    outlier_sequential = []
    for position in range(len(outliers_list)):
        if outliers_list[position] == 1:
            outlier_sequential.append(data['sequenceNotformatted'].iloc[position])
    return data, outlier_sequential

"""
def merge_longer_sequence_with_shorter():


def merge_shorter_sequence_with_longer():


def merge_outliers(outliers):
    merges = []
    for framework_count_1 in range(3):
        for framework_count_2 in range(3):
            for sequence_1 in framework_count_1:
                if framework_count_1 < framework_count_2:
                    



def create_main_subclone_family(outliers):
    allele_1_original = [np.unique(outliers[0]), np.unique(outliers[1]), np.unique(outliers[2])]
    subclones = []
    print(allele_1_original[0])
    fr2_used = np.zeros(len(allele_1_original[1]))
    for potential_outlier_1 in range(len(allele_1_original[0])):
        not_appended = True
        for potential_outlier_2 in range(len(allele_1_original[1])):
            fr1seq = allele_1_original[0][potential_outlier_1].replace('-', "")
            fr2seq = allele_1_original[1][potential_outlier_2].replace('-', "")
            alignments = pairwise2.align.globalxx(fr1seq, fr2seq, score_only=True)
            if len(fr2seq) - alignments <= 2:
                subclones.append([fr1seq, fr2seq])
                not_appended = False
                fr2_used[potential_outlier_2] = 1
        if not_appended:
            subclones.append([allele_1_original[0][potential_outlier_1].replace('-', "")])

    for potential_outlier_2 in range(len(allele_1_original[1])):
        if fr2_used[potential_outlier_2] == 0:
            subclones.append([allele_1_original[1][potential_outlier_2].replace('-', "")])

    subclones_final = []
    subclones_used = np.zeros(len(subclones))
    for potential_outlier_3 in range(len(allele_1_original[2])):
        not_appended = True
        fr3seq = outliers[2][potential_outlier_3].replace('-', "")
        if fr3seq == 'ACACGGCTGTGTATTACTGTGCGAGAGATCTGAGGAACGAAATGGCGGGGGATGGTGCGGGGAGTTAGTCGACTACTACTACTACTACTACATGTACGTCTGGGGCAAAGGGACCAC':
            print('Hi')
        for potential_outlier_4 in range(len(subclones)):
            alignments1 = pairwise2.align.globalxx(subclones[potential_outlier_4][0], fr3seq, score_only=True)
            # print(len(fr3seq) - alignments1)
            if len(fr3seq) - alignments1 <= 2:
                if fr3seq == 'ACACGGCTGTGTATTACTGTGCGAGAGATCTGAGGAACGAAATGGCGGGGGATGGTGCGGGGAGTTAGTCGACTACTACTACTACTACTACATGTACGTCTGGGGCAAAGGGACCAC':
                    print('Hi')
                '''
                if len((subclones[potential_outlier_4])) == 2:
                    alignments2 = pairwise2.align.globalxx(subclones[potential_outlier_4][1], fr3seq, score_only=True)
                    if len(fr3seq) - alignments2 <= 2:
                        subclones_final.append([subclones[potential_outlier_4][0], subclones[potential_outlier_4][1], fr3seq])
                        subclones_used[potential_outlier_4] = 1
                        not_appended = False
                else:
                    if fr3seq == 'ACACGGCTGTGTATTACTGTGCGAGAGATCTGAGGAACGAAATGGCGGGGGATGGTGCGGGGAGTTAGTCGACTACTACTACTACTACTACATGTACGTCTGGGGCAAAGGGACCAC':
                        print('Hi')
                    subclones_final.append([subclones[potential_outlier_4][0], fr3seq])
                    subclones_used[potential_outlier_4] = 1
                    not_appended = False
                
        if not_appended:
            subclones_final.append([allele_1_original[2][potential_outlier_3].replace('-', "")])
    for potential_outlier_4 in range(len(subclones)):
        if subclones[potential_outlier_4] == 0:
            subclones_final.append([subclones[potential_outlier_4]])
    print(subclones_final)
'''
"""


def partition(data, outliers):
    sequences = data['sequenceNotformatted'].tolist()
    outlier_position = list(range(len(outliers))) # Corresponding class of outlier sequence
    outlier_index = []   # Corresponding Outlier Index Value in the actual outliers
    for individual_outlier in outliers:
        outlier_index.append(data.index[data['sequenceNotformatted'] == individual_outlier])
        
    closest_match = []
    count = 0
    for sequence in sequences:
        outlier_score = len(sequence)
        best_outlier_position = -1
        outlier_seq_pos = 2 * len(sequences)
        for outlier_count in range(len(outliers)):
            alignments = pairwise2.align.globalms(sequence.replace("-", ""), outliers[outlier_count].replace("-", ""), 1, -1, -5, 0, score_only=True)
            if len(sequence) - alignments < outlier_score:
                outlier_score = len(sequence) - alignments
                best_outlier_position = outlier_position[outlier_count]
                outlier_seq_pos = outlier_index[outlier_count]
            if len(sequence) - alignments == outlier_score:
                if outlier_seq_pos - count > outlier_position[outlier_count] - count:
                    best_outlier_position = outlier_position[outlier_count]
                    outlier_seq_pos = outlier_index[outlier_count]
        if best_outlier_position == -1:
            pdb.set_trace()       
        closest_match.append(best_outlier_position)
        count += 1
    data['closest match'] = closest_match
    return data



def KevinsFunction(table_of_sequences):
    table_of_sequences['inserts']=table_of_sequences['inserts'].apply(lambda x: str(x))
    data, found_outlier = outlier_detection(table_of_sequences)
    partitioned_data = partition(data, found_outlier)
    
    return(partitioned_data)